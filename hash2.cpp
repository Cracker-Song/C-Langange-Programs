#include"hash.h"
Status InitHashTable(HashTable &H)// 操作结果: 构造一个空的哈希表
{  
   int i;
   H.count=0; // 当前元素个数为0
   H.sizeindex=0; // 初始存储容量为hashsize[0]
   m=hashsize[0];
   H.elem=(ElemType*)malloc(m*sizeof(ElemType));
   if(!H.elem)
     exit(OVERFLOW); // 存储分配失败
   for(i=0;i<m;i++)
     H.elem[i].key=NULLKEY; // 未填记录的标志
   return OK;
}
void DestroyHashTable(HashTable &H)// 初始条件: 哈希表H存在。操作结果: 销毁哈希表H
{  free(H.elem);
   H.elem=NULL;
   H.count=0;
   H.sizeindex=0;
}
unsigned Hash(KeyType K)// 一个简单的哈希函数(m为表长，全局变量)
{ return K%m;
}
void collision(int &p,int d) // 线性探测再散列
{ 
   p=(p+d)%m;// 开放定址法处理冲突
}
Status SearchHash(HashTable H,KeyType K,int &p,int &c)// 在开放定址哈希表H中查找关键码为K的元素,若查找成功,以p指示待查数据
{ p=Hash(K); // 求得哈希地址
   while(H.elem[p].key!=NULLKEY&&!EQ(K,H.elem[p].key))
   { // 该位置中填有记录．并且关键字不相等
     c++;
     if(c<m)
       collision(p,c); // 求得下一探查地址p
     else
       break;
   }
   if EQ(K,H.elem[p].key)
     return SUCCESS; // 查找成功，p返回待查数据元素位置
   else
     return UNSUCCESS; // 查找不成功(H.elem[p].key==NULLKEY)，p返回的是插入位置
}
Status InsertHash(HashTable &,ElemType); // 对函数的声明
void RecreateHashTable(HashTable &H) // 重建哈希表
{ 
   int i,count=H.count;
   ElemType *p,*elem=(ElemType*)malloc(count*sizeof(ElemType));
   p=elem;
   //printf("重建哈希表\n");
   for(i=0;i<m;i++) // 保存原有的数据到elem中
   if((H.elem+i)->key!=NULLKEY) // 该单元有数据
   *p++=*(H.elem+i);
   H.count=0;
   H.sizeindex++; // 增大存储容量
   m=hashsize[H.sizeindex];
   p=(ElemType*)realloc(H.elem,m*sizeof(ElemType));
   if(!p)
     exit(OVERFLOW); // 存储分配失败
   H.elem=p;
   for(i=0;i<m;i++)
     H.elem[i].key=NULLKEY; // 未填记录的标志(初始化)
   for(p=elem;p<elem+count;p++) // 将原有的数据按照新的表长插入到重建的哈希表中
     InsertHash(H,*p);
}
Status InsertHash(HashTable &H,ElemType e)// 查找不成功时插入数据元素e到开放定址哈希表H中，并返回OK；
{ int c,p;
   c=0;
   if(SearchHash(H,e.key,p,c)) // 表中已有与e有相同关键字的元素
     return DUPLICATE;
   else if(c<hashsize[H.sizeindex]/2) // 冲突次数c未达到上限,(c的阀值可调)
   { // 插入e
     H.elem[p]=e;
     ++H.count;
     return OK;
   }
   else
     RecreateHashTable(H); // 重建哈希表
   return ERROR;
}
void TraverseHash(HashTable H,void(*Vi)(int,ElemType))// 按哈希地址的顺序遍历哈希表
{ 
   printf("哈希地址0～%d\n",m-1);
   for(int i=0;i<m;i++)
     if(H.elem[i].key!=NULLKEY) // 有数据
       Vi(i,H.elem[i]);
}
Status Find(HashTable H,KeyType K,int &p)// 在开放定址哈希表H中查找关键码为K的元素,若查找成功,以p指示待查数据
{ int c=0;
   p=Hash(K); // 求得哈希地址
   while(H.elem[p].key!=NULLKEY&&!EQ(K,H.elem[p].key))// 该位置中填有记录．并且关键字不相等
   { 
     asl++;
     c++;
     if(c<m)
       collision(p,c); // 求得下一探查地址p
     else
     return UNSUCCESS; // 查找不成功(H.elem[p].key==NULLKEY)
   }
   if EQ(K,H.elem[p].key)
     return SUCCESS; // 查找成功，p返回待查数据元素位置
   else
     return UNSUCCESS; // 查找不成功(H.elem[p].key==NULLKEY)
}
void print(int p,ElemType r)//输出
{
   printf("address=%d (%d,%d)\n",p,r.key,r.ord);
}
int main(void)
{
	int choice=0;
	int delnum=0;
	int insertnum=0;
	int posinsert=0;
	ElemType r[15]={{49,1},{30,2},{10,3},{41,4},{57,5},{14,6},{47,7},{23,8},{53,9},{66,10},{18,11},{68,12},{20,13},{44,14}};
	HashTable h;
	//h=(HashTable *)malloc(sizeof(HashTable));
	int i,p;
    Status j;
    KeyType k;
	while(1)
	{
		printf("1.创建哈希表\n2.显示哈希表\n3.查找\n4.计算ASL\n5.删除\n6.插入\n7.退出\n");
		printf("请输入要选择的功能:\n");
		scanf("%d",&choice);
		switch(choice)
		{
			case 0:printf("输入错误\n");break;
			case 1:
				InitHashTable(h);
				for(i=0;i<N-1;i++)// 插入前N-1个记录
				{ 
					j=InsertHash(h,r[i]);
					if(j==DUPLICATE)
					printf("表中已有关键字为%d的记录，无法再插入记录(%d,%d)\n",r[i].key,r[i].key,r[i].ord);
				}
				//printf("%d\n",m);
				break;
			case 2:
				printf("按哈希地址的顺序遍历哈希表:\n");
				TraverseHash(h,print);
				break;
			case 3:
				asl=0;
				printf("请输入待查找记录的关键字: ");
				scanf("%d",&k);
				j=Find(h,k,p);
				if(j==SUCCESS)
					print(p,h.elem[p]);
				else
					printf("不存在该元素\n");
				break;
			case 4:
				asl=0;
				Find(h,49,p);
				Find(h,30,p);
				Find(h,10,p);
				Find(h,41,p);
				Find(h,57,p);
				Find(h,14,p);
				Find(h,47,p);
				Find(h,23,p);
				Find(h,53,p);
				Find(h,66,p);
				Find(h,18,p);
				Find(h,68,p);
				Find(h,20,p);
				Find(h,44,p);
				printf("%f\n",float(asl)/14);
				break;
			case 5:
				printf("请输入要删除的元素值\n");
				scanf("%d",&delnum);
				j=Find(h,delnum,p);
				if(j==SUCCESS)
				{
					for(int pos=h.elem[p].ord-1;pos<=14;)
					{
						//printf("%d\n",pos);
						r[pos].key=r[pos+1].key;
						//r[pos].ord=r[pos+1].ord;
						pos++;
					}
					//for(int pos=0;pos<14;printf("%d\n",r[pos].key),pos++);
					r[m].key=0;
					r[m].ord=0;
					m--;
					N--;
					//h.count--;
					DestroyHashTable(h);
					//print(p,h.elem[p]);
				}
					//print(p,h.elem[p]);
				else
					printf("不存在该元素\n");
				break;
			case 6:
				printf("请输入要插入的数\n");
				scanf("%d",&insertnum);
				m++;
				N++;
				r[13].key=insertnum;
				r[13].ord=14;
				DestroyHashTable(h);
				break;
				/*printf("请输入要插入的位置\n");
				scanf("%d",&posinsert);
				for(int pos=posinsert-1;pos<=15;)
				{
					//printf("%d\n",pos);
					r[pos].key=r[pos+1].key;
					//r[pos].ord=r[pos+1].ord;
					pos++;
				}
				//for(int pos=0;pos<14;printf("%d\n",r[pos].key),pos++);
				r[m].key=0;
				r[m].ord=0;
				m--;
				N--;
				//h.count--;
				DestroyHashTable(h);*/
			case 7:return 0;
		}
	}
   /*j=InsertHash(h,r[i]); // 插入第N个记录
   if(j==ERROR) // 重建哈希表
     j=InsertHash(h,r[i]); // 重建哈希表后重新插入
   printf("按哈希地址的顺序遍历重建后的哈希表:\n");
   TraverseHash(h,print);*/
}
